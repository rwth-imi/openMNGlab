import numpy as npfrom copy import deepcopyfrom plotting import colorsfrom matplotlib import pyplot as pltimport plotly.graph_objects as gofrom IPython.core.display import HTML, display## Convert threshold signal (constant) into dictionary (for plotting) with keys described below# @param threshold int | Threshold# @param signal_length int | Length of the signal vector, e.g. 30# @param freq float | Uniform difference between two neighboring datapoints within the file that we're using (e.g. 0.1)def convert_threshold_to_dict(threshold, signal_length, freq):        # segment_idx is -1, since it is not defined within a particular stimulus to stimulus time window         return {'y_values': np.ones(signal_length)*threshold,            'x_values': np.arange(0, signal_length, freq),            'color': 'red',            'name': 'Threshold',            'segment_idx': -1}   ## Convert Template into dictionaryy (for plotting) with keys described below. # @param template list | Threshold   # @param freq float | Uniform difference between two neighboring datapoints within the file that we're using (e.g. 0.1)def convert_template_to_dict(template, freq):        return {'y_values': template.signal_template,            'x_values': np.arange(0, template.length * freq, freq),            'color': 'red',            'name': 'Template',            'segment_idx': -1}   ## Find out whether do we have a correct AP within a particular time interval and segment idx# @param seg_idx int | Index of stimulus-to-stimulus timeframe for which we are checking occurence # @param trck_dict dict | From Dapsys.extract_segment_idxs_times()# @param pulses List[ElectricalStimulus] | Pulses that split the continuous recording signal# @param dt float| delay between a signal and preceding pulsedef is_correct_signal(seg_idx, trck_dict, pulses, dt):        if seg_idx in trck_dict and round(dt, 2) == round(trck_dict[seg_idx] - pulses[seg_idx].timepoint, 2):        return True    return False## Return time value for a peak occuring within an AP# @param signal ActionPotential | Signal from which we're extracting infodef get_signal_peak_timestamp(signal):        timestamps = np.linspace(signal.onset, signal.offset, num=len(signal.raw_signal))    return timestamps[np.argmax(signal.raw_signal)]## Get Pearson correlation's coefficient# @param amplitudes list | amplitude values for a signal# @param template list | template signal valuesdef get_correlation(amplitudes, template):        assert len(amplitudes) == len(template)        return np.corrcoef(amplitudes, template)[0, 1] ## Convert several APs to a form required for plotly# @param signals List[ActionPotential] | List of APs# @param pulses List[ElectricalStimulus] | Pulses that split the continuous recording signal# @param freq float | Uniform difference between two neighboring datapoints within the file that we're using (e.g. 0.1)# @param full_scale bool | True when applying conversion for full continuous recording plot, False when applying conversion only for signal plot# @param template TemplateActionPotentialTemplate | Template signal instance# @param trck_dict dict | From Dapsys.extract_segment_idxs_times()def convert_signals_to_dict(signals, pulses, freq, full_scale=False, template=None, trck_dict=None):        signals_list_of_dict = []    cols = colors.get_colors(cmap = plt.cm.Greens, length = 101)        for idx, signal in enumerate(signals):                y_values = signal.raw_signal        onset = signal.onset        offset = signal.offset        seg_idx = signal.features['stimulus_idx']        corr = get_correlation(y_values, template.signal_template)        if full_scale:            x_values = np.round(np.arange((onset - pulses[seg_idx].timepoint) * 1000 ,                                           (offset - pulses[seg_idx].timepoint) * 1000,                                           freq), 1)        else:            x_values = np.arange(0, template.length * freq, freq)                    color = cols[int(round(corr*100)-1)]        dt = get_signal_peak_timestamp(signal) - pulses[seg_idx].timepoint        name_val = f'Corr {round(corr,3)} | Seg {seg_idx+1} | Time Î”t={round(dt, 3)}'                if trck_dict and is_correct_signal(seg_idx, trck_dict, pulses, dt):            name_val += ' ðŸ‘Œ'            color = 'gold'                        signals_list_of_dict.append({'segment_idx': seg_idx,                            'y_values': y_values,                           'x_values': x_values,                           'corr': corr,                           'dt': dt,                           'name': name_val,                           'color': color                           })        return signals_list_of_dict## Convert list of dictionaries info of signals to traces for plotly# @param signals_to_dict List[dict] | From convert_signals_to_dict()def find_traces_amplitudes(signals_to_dict):        traces = []    for signal in signals_to_dict:        traces.append(go.Scatter(x=signal['x_values'],                                  y=signal['y_values'],                                  mode='lines',                                  line=dict(color=signal['color']),                                  fillcolor=signal['color'],                                  name=signal['name']))            return traces## Filter traces from find_traces() function based on correlation threshold# @param traces list | From get_above_threshold_signals() function above# @param threshold float | Correlation threshold inserted via notebookdef filter_traces(signals, thr):        filtered_sigs = []    for sig in signals:        if sig['corr'] > thr:            filtered_sigs.append(sig)    return filtered_sigs## Convert list of APs to dataframe form# @param aps list | From Dapsys.get_threshold_action_potentials()# @param template list | Template list valuesdef dict_to_df(aps, template):        corr_list = []        for ap in aps:        seg_idx = ap.features['stimulus_idx'] + 1  # Changing for non-cs people so that they don't get confused with 0 index        time = get_signal_peak_timestamp(ap) - ap.prev_stimuli["regular"].timepoint        corr = get_correlation(ap.raw_signal, template)        corr_list.append([seg_idx, time, corr])        return corr_list