import numpy as npfrom copy import deepcopyfrom plotting import colorsfrom matplotlib import pyplot as pltimport plotly.graph_objects as gofrom IPython.core.display import HTML, displaydef convert_threshold_to_dict(threshold, signal_length, freq):    '''    Given an amplitude threshold, convert that information into dictionary (for plotting) with keys described below.         Parameters	----------    threshold: int | Threshold.    signal_length: int | Length of the signal vector, e.g. 30.     freq: float | Uniform difference between two neighboring datapoints within the file that we're using (e.g. 0.1).     Returns	-------    dict | Dictionary with (hopefully) self-explanatory keys below.            segment_idx is -1, since it is not defined within a particular stimulus to stimulus time window.     '''          return {'y_values': np.ones(signal_length)*threshold,            'x_values': np.arange(0, signal_length, freq),            'color': 'red',            'name': 'Threshold',            'segment_idx': -1}   def convert_template_to_dict(template, freq):    '''    Given a signal template, convert that information into dictionary (for plotting) with keys described below.         Parameters	----------    template: list | Threshold.    freq: float | Uniform difference between two neighboring datapoints within the file that we're using (e.g. 0.1).     Returns	-------    dict | Dictionary with (hopefully) self-explanatory keys below.            segment_idx is -1, since it is not defined within a particular stimulus to stimulus time window.     '''         return {'y_values': template.signal_template,            'x_values': np.arange(0, template.length * freq, freq),            'color': 'red',            'name': 'Template',            'segment_idx': -1}   def is_correct_signal(seg_idx, trck_dict, pulses, dt):    '''    Find out whether do we have a correct AP within a particular time interval and segment idx.         Parameters	----------    seg_idx: int | Index of stimulus-to-stimulus timeframe for which we are checking occurence.     trck_dict: dict | From Dapsys.extract_segment_idxs_times()    pulses: List[ElectricalStimulus] | Pulses that split the continuous recording signal.     dt: delay between a signal and preceding pulse.     Returns	-------    bool | Does the signal delay (dt) correspond to a correct AP.     '''       if seg_idx in trck_dict and round(dt, 2) == round(trck_dict[seg_idx] - pulses[seg_idx].timepoint, 2):        return True    return Falsedef get_signal_peak_timestamp(signal):    '''    Return time value for a peak occuring within an AP.           Parameters	----------    signal: ActionPotential | Signal from which we're extracting info.         Returns	-------    float | Exact timestamp of occuring     '''         timestamps = np.linspace(signal.onset, signal.offset, num=len(signal.raw_signal))    return timestamps[np.argmax(signal.raw_signal)]def get_correlation(amplitudes, template):    '''    Pearson correlation's coefficient.         Parameters	----------    amplitudes: list | amplitude values for a signal.    template: list | template signal values.        Returns	-------    float | Pearson's correlation coefficient between -1 and 1.    '''       assert len(amplitudes) == len(template)        return np.corrcoef(amplitudes, template)[0, 1] def convert_signals_to_dict(signals, pulses, freq, full_scale=False, template=None, trck_dict=None):    '''    Convert APs to a form required for plotly.         Parameters	----------    signals: List[ActionPotential] | List of APs.    pulses: List[ElectricalStimulus] | Pulses that split the continuous recording signal.     freq: float | Uniform difference between two neighboring datapoints within the file that we're using (e.g. 0.1).     full_scale: bool | True when applying conversion for full continuous recording plot, False when applying conversion only for signal plot.     template: TemplateActionPotentialTemplate | Template signal instance.     trck_dict: dict | From Dapsys.extract_segment_idxs_times()        Returns	-------    list | list of dictionaries, where each dictionary represents AP instance information.     '''             signals_list_of_dict = []    cols = colors.get_colors(cmap = plt.cm.Greens, length = 101)        for idx, signal in enumerate(signals):                y_values = signal.raw_signal        onset = signal.onset        offset = signal.offset        seg_idx = signal.features['stimulus_idx']        corr = get_correlation(y_values, template.signal_template)        if full_scale:            x_values = np.round(np.arange((onset - pulses[seg_idx].timepoint) * 1000 ,                                           (offset - pulses[seg_idx].timepoint) * 1000,                                           freq), 1)        else:            x_values = np.arange(0, template.length * freq, freq)                    color = cols[int(round(corr*100)-1)]        dt = get_signal_peak_timestamp(signal) - pulses[seg_idx].timepoint        name_val = f'Corr {round(corr,3)} | Seg {seg_idx+1} | Time Î”t={round(dt, 3)}'                if trck_dict and is_correct_signal(seg_idx, trck_dict, pulses, dt):            name_val += ' ðŸ‘Œ'            color = 'gold'                        signals_list_of_dict.append({'segment_idx': seg_idx,                            'y_values': y_values,                           'x_values': x_values,                           'corr': corr,                           'dt': dt,                           'name': name_val,                           'color': color                           })        return signals_list_of_dictdef find_traces_amplitudes(signals_to_dict):    '''    Convert list of dictionaries info of signals to traces for plotly.         Parameters	----------    signals_to_dict: List[dict] | From convert_signals_to_dict().        Returns	-------    List[go.Scatter] | list of scatter instances for plotting     '''           traces = []    for signal in signals_to_dict:        traces.append(go.Scatter(x=signal['x_values'],                                  y=signal['y_values'],                                  mode='lines',                                  line=dict(color=signal['color']),                                  fillcolor=signal['color'],                                  name=signal['name']))            return tracesdef filter_traces(signals, thr):    '''    Filtering traces from find_traces() function based on correlation threshold.        Parameters	----------    traces: list | From get_above_threshold_signals() function above.    threshold: float | Correlation threshold inserted via notebook.     Returns	-------    new_traces: list | Filtered traces.     '''         filtered_sigs = []    for sig in signals:        if sig['corr'] > thr:            filtered_sigs.append(sig)    return filtered_sigsdef dict_to_df(aps, template):    '''    Convert list of APs to dataframe form.          Parameters	----------    aps: list | From Dapsys.get_threshold_action_potentials().    template: list | Template list values.     Returns	-------    list | List of values in form [seg_idx, latency, correlation]    '''         corr_list = []        for ap in aps:        seg_idx = ap.features['stimulus_idx']        time = get_signal_peak_timestamp(ap) - ap.prev_stimuli["regular"].timepoint        corr = get_correlation(ap.raw_signal, template)        corr_list.append([seg_idx, time, corr])        return corr_list